<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>esbmtk.carbonate_chemisrty API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>esbmtk.carbonate_chemisrty</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from numbers import Number
from nptyping import *
from typing import *
from numpy import array, set_printoptions, arange, zeros, interp, mean
from copy import deepcopy, copy
from time import process_time

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

import logging
import time
import builtins
from .esbmtk import esbmtkBase, Model, Reservoir, VirtualReservoir

class SeawaterConstants(esbmtkBase):
    &#34;&#34;&#34;Provide basic seawater properties as a function of T and Salinity.
    Pressure may come at a later stage

    Example:

    Seawater(name=&#34;SW&#34;,
             model=
             temperature = optional in C, defaults to 25
             salinity  = optional in psu, defaults to 35
             pressure = optional, defaults to 0 bars = 1atm
             pH = optional, defaults to 8.1
            )

    useful methods:

    SW.show() will list all known values

    After initialization this class provides access to each value the following way

    instance_name.variable_name

    &#34;&#34;&#34;

    def __init__(self, **kwargs: Dict[str, str]):

        import math

        # dict of all known keywords and their type
        self.lkk: Dict[str, any] = {
            &#34;name&#34;: str,
            &#34;model&#34;: Model,
            &#34;salinity&#34;: (int, float),
            &#34;temperature&#34;: (int, float),
            &#34;pH&#34;: (int, float),
            &#34;pressure&#34;: Number,
        }

        # provide a list of absolutely required keywords
        self.lrk: list = [&#34;name&#34;]
        # list of default values if none provided
        self.lod: Dict[str, any] = {
            &#34;salinity&#34;: 35.0,
            &#34;temperature&#34;: 25.0,
            &#34;pH&#34;: 8.1,
            &#34;pressure&#34;: 0,
        }

        # validate input and initialize instance variables
        self.__initerrormessages__()
        self.__validateandregister__(kwargs)  # initialize keyword values

        # legacy names
        self.n: str = self.name  # string =  name of this instance
        self.mo: Model = self.model
        self.hplus = 10 ** -self.pH
        self.constants: list = [&#34;K0&#34;, &#34;K1&#34;, &#34;K2&#34;, &#34;KW&#34;, &#34;KB&#34;]
        self.species: list = [
            &#34;dic&#34;,
            &#34;ta&#34;,
            &#34;ca&#34;,
            &#34;co2&#34;,
            &#34;hco3&#34;,
            &#34;co3&#34;,
            &#34;boron&#34;,
            &#34;boh4&#34;,
            &#34;boh3&#34;,
            &#34;oh&#34;,
        ]

        self.update()
        self.__register_name__()

    def update(self, **kwargs: dict) -&gt; None:
        &#34;&#34;&#34;Update values if necessary&#34;&#34;&#34;

        from math import log10

        if kwargs:
            self.lrk: list = []
            self.__validateandregister__(kwargs)

        # update K values and species concentrations according to P, S, and T
        self.__init_std_seawater__()
        self.__init_carbon__()
        self.__init_boron__()
        self.__init_water__()

        # get total alkalinity

        self.ca = self.hco3 + 2 * self.co3
        self.ta = self.ca + self.boh4 + self.oh - self.hplus

        # update pk values
        for n in self.constants:
            v = getattr(self, n)
            pk = f&#34;p{n.lower()}&#34;
            setattr(self, pk, -log10(v))

    def show(self) -&gt; None:
        &#34;&#34;&#34;Printout pK values. &#34;&#34;&#34;

        from math import log10

        for n in self.species:
            v = getattr(self, n)
            print(f&#34;{n} = {v * 1E6:.2f} nmol/l&#34;)

        print(f&#34;pH = {-log10(self.hplus):.2f}\n&#34;)
        print(f&#34;salinity = {self.salinity:.2f}&#34;)
        print(f&#34;temperature = {self.temperature:.2f}\n&#34;)

        for n in self.constants:
            K = getattr(self, n)
            pk = getattr(self, f&#34;p{n.lower()}&#34;)
            print(f&#34;{n} = {K:.2e}, p{n} = {pk:.2f}&#34;)

    def __init_std_seawater__(self) -&gt; None:
        &#34;&#34;&#34;Provide values for standard seawater. Data after Zeebe and Gladrow
        all values in mol/kg. To convert to seawater these values need to be
        multiplied by sw

        &#34;&#34;&#34;

        S = self.salinity
        swc = (1000 + S) / 1000
        self.dic = 0.00204 * swc
        self.boron = 0.00042 * swc
        self.oh = 0.00001 * swc

    def __init_carbon__(self) -&gt; None:
        &#34;&#34;&#34;Calculate the carbon equilibrium values as function of
        temperature T and salinity S

        &#34;&#34;&#34;

        from math import exp, log, log10

        T = 273.15 + self.temperature
        S = self.salinity

        # After Weiss 1974
        lnK0: float = (
            93.4517 * 100 / T
            - 60.2409
            + 23.3585 * log(T / 100)
            + S * (0.023517 - 0.023656 * T / 100 + 0.0047036 * (T / 100) ** 2)
        )

        lnk1: float = (
            -2307.1266 / T
            + 2.83655
            - 1.5529413 * log(T)
            + S ** 0.5 * (-4.0484 / T - 0.20760841)
            + S * 0.08468345
            + S ** (3 / 2) * -0.00654208
            + log(1 - 0.001006 * S)
        )

        lnk2: float = (
            -9.226508
            - 3351.6106 / T
            - 0.2005743 * log(T)
            + (-0.106901773 - 23.9722 / T) * S ** 0.5
            + 0.1130822 * S
            - 0.00846934 * S ** 1.5
            + log(1 - 0.001006 * S)
        )

        self.K0: float = exp(lnK0)
        self.K1: float = exp(lnk1)
        self.K2: float = exp(lnk2)

        self.K1 = self.__pressure_correction__(&#34;K1&#34;, self.K1)
        self.K2 = self.__pressure_correction__(&#34;K2&#34;, self.K2)

        self.co2 = self.dic / (
            1 + self.K1 / self.hplus + self.K1 * self.K2 / self.hplus ** 2
        )
        self.hco3 = self.dic / (1 + self.hplus / self.K1 + self.K2 / self.hplus)
        self.co3 = self.dic / (
            1 + self.hplus / self.K2 + self.hplus ** 2 / (self.K1 * self.K2)
        )

    def __init_boron__(self) -&gt; None:
        &#34;&#34;&#34;Calculate the boron equilibrium values as function of
        temperature T and salinity S

        &#34;&#34;&#34;

        from math import exp, log

        T = 273.15 + self.temperature
        S = self.salinity

        lnkb = (
            (
                -8966.9
                - 2890.53 * S ** 0.5
                - 77.942 * S
                + 1.728 * S ** 1.5
                - 0.0996 * S ** 2
            )
            / T
            + 148.0248
            + 137.1942 * S ** 0.5
            + 1.62142 * S
            - (24.4344 + 25.085 * S ** 0.5 + 0.2474 * S) * log(T)
            + 0.053105 * S ** 0.5 * T
        )

        self.KB = exp(lnkb)
        self.KB = self.__pressure_correction__(&#34;KB&#34;, self.KB)

        self.boh4 = self.boron * self.KB / (self.hplus + self.KB)
        self.boh3 = self.boron - self.boh4

    def __init_water__(self) -&gt; None:
        &#34;&#34;&#34;Calculate the water equilibrium values as function of
        temperature T and salinity S

        &#34;&#34;&#34;

        from math import exp, log

        T = 273.15 + self.temperature
        S = self.salinity

        lnKW = (
            148.96502
            - 13847.27 / T
            - 23.6521 * log(T)
            + (118.67 / T - 5.977 + 1.0495 * log(T)) * S ** 0.5
            - 0.01615 * S
        )
        self.KW = exp(lnKW)
        self.KW = self.__pressure_correction__(&#34;KW&#34;, self.KW)
        self.oh = self.KW / self.hplus

    def __pressure_correction__(self, n: str, K: float) -&gt; float:
        &#34;&#34;&#34;Correct K-values for pressure. After Zeebe and Wolf Gladrow 2001

        name = name of K-value, i.e. &#34;K1&#34;
        K = uncorrected value
        T = temperature in Deg C
        P = pressure in atm
        &#34;&#34;&#34;

        from math import exp, log

        R: float = 83.131
        Tc: float = self.temperature
        T: float = 273.15 + Tc
        P: float = self.pressure
        RT: float = R * T

        A: dict = {}
        A[&#34;K1&#34;]: list = [25.50, 0.1271, 0.0, 3.08, 0.0877]
        A[&#34;K2&#34;]: list = [15.82, -0.0219, 0.0, -1.13, -0.1475]
        A[&#34;KB&#34;]: list = [29.48, 0.1622, 2.6080, 2.84, 0.0]
        A[&#34;KW&#34;]: list = [25.60, 0.2324, -3.6246, 5.13, 0.0794]
        A[&#34;KS&#34;]: list = [18.03, 0.0466, 0.3160, 4.53, 0.0900]
        A[&#34;KF&#34;]: list = [9.780, -0.0090, -0.942, 3.91, 0.054]
        A[&#34;Kca&#34;]: list = [48.76, 0.5304, 0.0, 11.76, 0.3692]
        A[&#34;Kar&#34;]: list = [46.00, 0.5304, 0.0, 11.76, 0.3692]

        a: list = A[n]

        DV: float = -a[0] + (a[1] * Tc) + (a[2] / 1000 * Tc ** 2)
        DK: float = -a[3] / 1000 + (a[4] / 1000 * Tc) + (0 * Tc ** 2)

        # print(f&#34;DV = {DV}&#34;)
        # print(f&#34;DK = {DK}&#34;)
        # print(f&#34;log k= {log(K)}&#34;)

        lnkp: float = -(DV / RT) * P + (0.5 * DK / RT) * P ** 2 + log(K)
        # print(lnkp)

        return exp(lnkp)

def calc_H(
    i: int,
    a1: Union[Reservoir, VirtualReservoir],
    a2: Union[Reservoir, VirtualReservoir],
    a3: SeawaterConstants,
    a4=0,
    a5=0,
    a6=0,
) -&gt; tuple:

    &#34;&#34;&#34;

    This function will calculate the H+ concentration at t=i
    time step. Returns a tuple in the form of [m, l, h] which pertains to
    the mass, and respective isotopes of the element. l and h will
    default to 1. Calculations are based off equations from Follows et al., 2006.
    doi:10.1016/j.ocemod.2005.05.004

    a1 = carbonate alkalinity reservoir object
    a2 = dic reservoir object
    a3 = SeawaterConstants object

    i = index of current timestep
    a1 to a6 = optional fcn parameters. These must be present
    even if your function will not use it. These will default to 0.

    Limitations: Assumes concentrations are in mol/L


    This function can then be used in conjunction with a VirtualReservoir, e.g.,

    VirtualReservoir(
         name=&#34;V_H&#34;,
         species=Hplus,
         concentration=f&#34;{SW.hplus*1000} mmol/l&#34;,
         volume=volume,
         plot_transform_c=phc,
         legend_left=&#34;pH&#34;,
         function=calc_H,
         a1=V_CA,
         a2=DIC,
         a3=SW,
    )

    Author: M. Niazi &amp; T. Tsan, 2021

    &#34;&#34;&#34;

    CA: float = a1.c[i - 1]  # mol/L
    DIC: float = a2.c[i - 1]  # mol/L
    SW: SeawaterConstants = a3  #

    k1: float = SW.K1
    k2: float = SW.K2

    gamm: float = DIC / CA
    dummy: float = (1 - gamm) * (1 - gamm) * k1 * k1 - 4 * k1 * k2 * (1 - (2 * gamm))
    m: float = (0.5 * ((gamm - 1) * k1 + (dummy ** 0.5))) + ext_h
    l: float = 1.0
    h: float = 1.0

    return [m, l, h]


def calc_CA(
    i: int,
    a1: Union[Reservoir, VirtualReservoir],
    a2: Union[Reservoir, VirtualReservoir],
    a3: SeawaterConstants,
    a4=0,
    a5=0,
    a6=0,
) -&gt; tuple:

    &#34;&#34;&#34;
    This function will calculate the carbonate alkalinity concentration
    at the ith time step. Returns a tuple in the form of [m, l, h]
    which pertains to the mass, and respective isotopes. For carbonate
    alkalinity, m will equal to the amount of carbonate alkalinity in
    mol/L and l and h will default to 1.  Calculations are based off
    equations from Follows et al., 2006.
    doi:10.1016/j.ocemod.2005.05.004


    a1 = total alkalinity reservoir object
    a2 = H+ reservoir reservoir object
    a3 = SeawaterConstants object

    i = index of current timestep
    a1 to a6 = optional fcn parameters. These must be present
    even if your function will not use it

    Limitations: Assumes concentrations are in mol/L

    This function can then be used in conjunction with a VirtualReservoir, e.g.,

    VirtualReservoir(
         name=&#34;V_H&#34;,
         species=Hplus,
         concentration=f&#34;{SW.hplus*1000} mmol/l&#34;,
         volume=volume,
         plot_transform_c=phc,
         legend_left=&#34;pH&#34;,
         function=calc_H,
         a1=V_CA,
         a2=DIC,
         a3=SW,
    )

    Author: M. Niazi &amp; T. Tsan, 2021

    &#34;&#34;&#34;

    ta: float = a1.c[i - 1]  # mol/L
    hplus: float = a2.c[i - 1]  # mol/L
    SW: SeawaterConstants = a3

    oh: float = SW.KW / hplus
    boh4: float = SW.boron * SW.KB / (hplus + SW.KB)

    fg: float = hplus - oh - boh4  # mol/L

    m: float = ta + fg
    l: float = 1
    h: float = 1

    return [m, l, h]

def calc_pCO2(
    dic: Union[Reservoir, VirtualReservoir],
    hplus: Union[Reservoir, VirtualReservoir],
    SW: SeawaterConstants,
) -&gt; [NDArray, Float]:

    &#34;&#34;&#34;
    Calculate the concentration of pCO2 as a function of DIC,
    H+, K1 and k2 and returns a numpy array containing
    the pCO2 in uatm at each timestep. Calculations are based off
    equations from Follows, 2006. doi:10.1016/j.ocemod.2005.05.004

    DIC: Reservoir  = DIC concentrations in mol/liter
    Hplus: Reservoir = H+ concentrations in mol/liter
    SW: Seawater = Seawater object for the model

    Limitations
    Author: T. Tsan

    &#34;&#34;&#34;

    dic_c: [NDArray, Float] = dic.c
    hplus_c: [NDArray, Float] = hplus.c

    k1: float = SW.K1
    k2: float = SW.K2

    co2: [NDArray, Float] = dic_c / (1 + (k1 / hplus_c) + (k1 * k2 / (hplus_c ** 2)))

    pco2: [NDArray, Float] = co2 / SW.K0 * 1E6

    return pco2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="esbmtk.carbonate_chemisrty.calc_CA"><code class="name flex">
<span>def <span class="ident">calc_CA</span></span>(<span>i: int, a1: Union[<a title="esbmtk.esbmtk.Reservoir" href="esbmtk.html#esbmtk.esbmtk.Reservoir">Reservoir</a>, <a title="esbmtk.esbmtk.VirtualReservoir" href="esbmtk.html#esbmtk.esbmtk.VirtualReservoir">VirtualReservoir</a>], a2: Union[<a title="esbmtk.esbmtk.Reservoir" href="esbmtk.html#esbmtk.esbmtk.Reservoir">Reservoir</a>, <a title="esbmtk.esbmtk.VirtualReservoir" href="esbmtk.html#esbmtk.esbmtk.VirtualReservoir">VirtualReservoir</a>], a3: <a title="esbmtk.carbonate_chemisrty.SeawaterConstants" href="#esbmtk.carbonate_chemisrty.SeawaterConstants">SeawaterConstants</a>, a4=0, a5=0, a6=0) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>This function will calculate the carbonate alkalinity concentration
at the ith time step. Returns a tuple in the form of [m, l, h]
which pertains to the mass, and respective isotopes. For carbonate
alkalinity, m will equal to the amount of carbonate alkalinity in
mol/L and l and h will default to 1.
Calculations are based off
equations from Follows et al., 2006.
doi:10.1016/j.ocemod.2005.05.004</p>
<p>a1 = total alkalinity reservoir object
a2 = H+ reservoir reservoir object
a3 = SeawaterConstants object</p>
<p>i = index of current timestep
a1 to a6 = optional fcn parameters. These must be present
even if your function will not use it</p>
<p>Limitations: Assumes concentrations are in mol/L</p>
<p>This function can then be used in conjunction with a VirtualReservoir, e.g.,</p>
<p>VirtualReservoir(
name="V_H",
species=Hplus,
concentration=f"{SW.hplus*1000} mmol/l",
volume=volume,
plot_transform_c=phc,
legend_left="pH",
function=calc_H,
a1=V_CA,
a2=DIC,
a3=SW,
)</p>
<p>Author: M. Niazi &amp; T. Tsan, 2021</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_CA(
    i: int,
    a1: Union[Reservoir, VirtualReservoir],
    a2: Union[Reservoir, VirtualReservoir],
    a3: SeawaterConstants,
    a4=0,
    a5=0,
    a6=0,
) -&gt; tuple:

    &#34;&#34;&#34;
    This function will calculate the carbonate alkalinity concentration
    at the ith time step. Returns a tuple in the form of [m, l, h]
    which pertains to the mass, and respective isotopes. For carbonate
    alkalinity, m will equal to the amount of carbonate alkalinity in
    mol/L and l and h will default to 1.  Calculations are based off
    equations from Follows et al., 2006.
    doi:10.1016/j.ocemod.2005.05.004


    a1 = total alkalinity reservoir object
    a2 = H+ reservoir reservoir object
    a3 = SeawaterConstants object

    i = index of current timestep
    a1 to a6 = optional fcn parameters. These must be present
    even if your function will not use it

    Limitations: Assumes concentrations are in mol/L

    This function can then be used in conjunction with a VirtualReservoir, e.g.,

    VirtualReservoir(
         name=&#34;V_H&#34;,
         species=Hplus,
         concentration=f&#34;{SW.hplus*1000} mmol/l&#34;,
         volume=volume,
         plot_transform_c=phc,
         legend_left=&#34;pH&#34;,
         function=calc_H,
         a1=V_CA,
         a2=DIC,
         a3=SW,
    )

    Author: M. Niazi &amp; T. Tsan, 2021

    &#34;&#34;&#34;

    ta: float = a1.c[i - 1]  # mol/L
    hplus: float = a2.c[i - 1]  # mol/L
    SW: SeawaterConstants = a3

    oh: float = SW.KW / hplus
    boh4: float = SW.boron * SW.KB / (hplus + SW.KB)

    fg: float = hplus - oh - boh4  # mol/L

    m: float = ta + fg
    l: float = 1
    h: float = 1

    return [m, l, h]</code></pre>
</details>
</dd>
<dt id="esbmtk.carbonate_chemisrty.calc_H"><code class="name flex">
<span>def <span class="ident">calc_H</span></span>(<span>i: int, a1: Union[<a title="esbmtk.esbmtk.Reservoir" href="esbmtk.html#esbmtk.esbmtk.Reservoir">Reservoir</a>, <a title="esbmtk.esbmtk.VirtualReservoir" href="esbmtk.html#esbmtk.esbmtk.VirtualReservoir">VirtualReservoir</a>], a2: Union[<a title="esbmtk.esbmtk.Reservoir" href="esbmtk.html#esbmtk.esbmtk.Reservoir">Reservoir</a>, <a title="esbmtk.esbmtk.VirtualReservoir" href="esbmtk.html#esbmtk.esbmtk.VirtualReservoir">VirtualReservoir</a>], a3: <a title="esbmtk.carbonate_chemisrty.SeawaterConstants" href="#esbmtk.carbonate_chemisrty.SeawaterConstants">SeawaterConstants</a>, a4=0, a5=0, a6=0) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>This function will calculate the H+ concentration at t=i
time step. Returns a tuple in the form of [m, l, h] which pertains to
the mass, and respective isotopes of the element. l and h will
default to 1. Calculations are based off equations from Follows et al., 2006.
doi:10.1016/j.ocemod.2005.05.004</p>
<p>a1 = carbonate alkalinity reservoir object
a2 = dic reservoir object
a3 = SeawaterConstants object</p>
<p>i = index of current timestep
a1 to a6 = optional fcn parameters. These must be present
even if your function will not use it. These will default to 0.</p>
<p>Limitations: Assumes concentrations are in mol/L</p>
<p>This function can then be used in conjunction with a VirtualReservoir, e.g.,</p>
<p>VirtualReservoir(
name="V_H",
species=Hplus,
concentration=f"{SW.hplus*1000} mmol/l",
volume=volume,
plot_transform_c=phc,
legend_left="pH",
function=calc_H,
a1=V_CA,
a2=DIC,
a3=SW,
)</p>
<p>Author: M. Niazi &amp; T. Tsan, 2021</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_H(
    i: int,
    a1: Union[Reservoir, VirtualReservoir],
    a2: Union[Reservoir, VirtualReservoir],
    a3: SeawaterConstants,
    a4=0,
    a5=0,
    a6=0,
) -&gt; tuple:

    &#34;&#34;&#34;

    This function will calculate the H+ concentration at t=i
    time step. Returns a tuple in the form of [m, l, h] which pertains to
    the mass, and respective isotopes of the element. l and h will
    default to 1. Calculations are based off equations from Follows et al., 2006.
    doi:10.1016/j.ocemod.2005.05.004

    a1 = carbonate alkalinity reservoir object
    a2 = dic reservoir object
    a3 = SeawaterConstants object

    i = index of current timestep
    a1 to a6 = optional fcn parameters. These must be present
    even if your function will not use it. These will default to 0.

    Limitations: Assumes concentrations are in mol/L


    This function can then be used in conjunction with a VirtualReservoir, e.g.,

    VirtualReservoir(
         name=&#34;V_H&#34;,
         species=Hplus,
         concentration=f&#34;{SW.hplus*1000} mmol/l&#34;,
         volume=volume,
         plot_transform_c=phc,
         legend_left=&#34;pH&#34;,
         function=calc_H,
         a1=V_CA,
         a2=DIC,
         a3=SW,
    )

    Author: M. Niazi &amp; T. Tsan, 2021

    &#34;&#34;&#34;

    CA: float = a1.c[i - 1]  # mol/L
    DIC: float = a2.c[i - 1]  # mol/L
    SW: SeawaterConstants = a3  #

    k1: float = SW.K1
    k2: float = SW.K2

    gamm: float = DIC / CA
    dummy: float = (1 - gamm) * (1 - gamm) * k1 * k1 - 4 * k1 * k2 * (1 - (2 * gamm))
    m: float = (0.5 * ((gamm - 1) * k1 + (dummy ** 0.5))) + ext_h
    l: float = 1.0
    h: float = 1.0

    return [m, l, h]</code></pre>
</details>
</dd>
<dt id="esbmtk.carbonate_chemisrty.calc_pCO2"><code class="name flex">
<span>def <span class="ident">calc_pCO2</span></span>(<span>dic: Union[<a title="esbmtk.esbmtk.Reservoir" href="esbmtk.html#esbmtk.esbmtk.Reservoir">Reservoir</a>, <a title="esbmtk.esbmtk.VirtualReservoir" href="esbmtk.html#esbmtk.esbmtk.VirtualReservoir">VirtualReservoir</a>], hplus: Union[<a title="esbmtk.esbmtk.Reservoir" href="esbmtk.html#esbmtk.esbmtk.Reservoir">Reservoir</a>, <a title="esbmtk.esbmtk.VirtualReservoir" href="esbmtk.html#esbmtk.esbmtk.VirtualReservoir">VirtualReservoir</a>], SW: <a title="esbmtk.carbonate_chemisrty.SeawaterConstants" href="#esbmtk.carbonate_chemisrty.SeawaterConstants">SeawaterConstants</a>) ‑> [NDArray[(typing.Any, ...), typing.Any], Float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the concentration of pCO2 as a function of DIC,
H+, K1 and k2 and returns a numpy array containing
the pCO2 in uatm at each timestep. Calculations are based off
equations from Follows, 2006. doi:10.1016/j.ocemod.2005.05.004</p>
<p>DIC: Reservoir
= DIC concentrations in mol/liter
Hplus: Reservoir = H+ concentrations in mol/liter
SW: Seawater = Seawater object for the model</p>
<p>Limitations
Author: T. Tsan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_pCO2(
    dic: Union[Reservoir, VirtualReservoir],
    hplus: Union[Reservoir, VirtualReservoir],
    SW: SeawaterConstants,
) -&gt; [NDArray, Float]:

    &#34;&#34;&#34;
    Calculate the concentration of pCO2 as a function of DIC,
    H+, K1 and k2 and returns a numpy array containing
    the pCO2 in uatm at each timestep. Calculations are based off
    equations from Follows, 2006. doi:10.1016/j.ocemod.2005.05.004

    DIC: Reservoir  = DIC concentrations in mol/liter
    Hplus: Reservoir = H+ concentrations in mol/liter
    SW: Seawater = Seawater object for the model

    Limitations
    Author: T. Tsan

    &#34;&#34;&#34;

    dic_c: [NDArray, Float] = dic.c
    hplus_c: [NDArray, Float] = hplus.c

    k1: float = SW.K1
    k2: float = SW.K2

    co2: [NDArray, Float] = dic_c / (1 + (k1 / hplus_c) + (k1 * k2 / (hplus_c ** 2)))

    pco2: [NDArray, Float] = co2 / SW.K0 * 1E6

    return pco2</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="esbmtk.carbonate_chemisrty.SeawaterConstants"><code class="flex name class">
<span>class <span class="ident">SeawaterConstants</span></span>
<span>(</span><span>**kwargs: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Provide basic seawater properties as a function of T and Salinity.
Pressure may come at a later stage</p>
<p>Example:</p>
<p>Seawater(name="SW",
model=
temperature = optional in C, defaults to 25
salinity
= optional in psu, defaults to 35
pressure = optional, defaults to 0 bars = 1atm
pH = optional, defaults to 8.1
)</p>
<p>useful methods:</p>
<p>SW.show() will list all known values</p>
<p>After initialization this class provides access to each value the following way</p>
<p>instance_name.variable_name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SeawaterConstants(esbmtkBase):
    &#34;&#34;&#34;Provide basic seawater properties as a function of T and Salinity.
    Pressure may come at a later stage

    Example:

    Seawater(name=&#34;SW&#34;,
             model=
             temperature = optional in C, defaults to 25
             salinity  = optional in psu, defaults to 35
             pressure = optional, defaults to 0 bars = 1atm
             pH = optional, defaults to 8.1
            )

    useful methods:

    SW.show() will list all known values

    After initialization this class provides access to each value the following way

    instance_name.variable_name

    &#34;&#34;&#34;

    def __init__(self, **kwargs: Dict[str, str]):

        import math

        # dict of all known keywords and their type
        self.lkk: Dict[str, any] = {
            &#34;name&#34;: str,
            &#34;model&#34;: Model,
            &#34;salinity&#34;: (int, float),
            &#34;temperature&#34;: (int, float),
            &#34;pH&#34;: (int, float),
            &#34;pressure&#34;: Number,
        }

        # provide a list of absolutely required keywords
        self.lrk: list = [&#34;name&#34;]
        # list of default values if none provided
        self.lod: Dict[str, any] = {
            &#34;salinity&#34;: 35.0,
            &#34;temperature&#34;: 25.0,
            &#34;pH&#34;: 8.1,
            &#34;pressure&#34;: 0,
        }

        # validate input and initialize instance variables
        self.__initerrormessages__()
        self.__validateandregister__(kwargs)  # initialize keyword values

        # legacy names
        self.n: str = self.name  # string =  name of this instance
        self.mo: Model = self.model
        self.hplus = 10 ** -self.pH
        self.constants: list = [&#34;K0&#34;, &#34;K1&#34;, &#34;K2&#34;, &#34;KW&#34;, &#34;KB&#34;]
        self.species: list = [
            &#34;dic&#34;,
            &#34;ta&#34;,
            &#34;ca&#34;,
            &#34;co2&#34;,
            &#34;hco3&#34;,
            &#34;co3&#34;,
            &#34;boron&#34;,
            &#34;boh4&#34;,
            &#34;boh3&#34;,
            &#34;oh&#34;,
        ]

        self.update()
        self.__register_name__()

    def update(self, **kwargs: dict) -&gt; None:
        &#34;&#34;&#34;Update values if necessary&#34;&#34;&#34;

        from math import log10

        if kwargs:
            self.lrk: list = []
            self.__validateandregister__(kwargs)

        # update K values and species concentrations according to P, S, and T
        self.__init_std_seawater__()
        self.__init_carbon__()
        self.__init_boron__()
        self.__init_water__()

        # get total alkalinity

        self.ca = self.hco3 + 2 * self.co3
        self.ta = self.ca + self.boh4 + self.oh - self.hplus

        # update pk values
        for n in self.constants:
            v = getattr(self, n)
            pk = f&#34;p{n.lower()}&#34;
            setattr(self, pk, -log10(v))

    def show(self) -&gt; None:
        &#34;&#34;&#34;Printout pK values. &#34;&#34;&#34;

        from math import log10

        for n in self.species:
            v = getattr(self, n)
            print(f&#34;{n} = {v * 1E6:.2f} nmol/l&#34;)

        print(f&#34;pH = {-log10(self.hplus):.2f}\n&#34;)
        print(f&#34;salinity = {self.salinity:.2f}&#34;)
        print(f&#34;temperature = {self.temperature:.2f}\n&#34;)

        for n in self.constants:
            K = getattr(self, n)
            pk = getattr(self, f&#34;p{n.lower()}&#34;)
            print(f&#34;{n} = {K:.2e}, p{n} = {pk:.2f}&#34;)

    def __init_std_seawater__(self) -&gt; None:
        &#34;&#34;&#34;Provide values for standard seawater. Data after Zeebe and Gladrow
        all values in mol/kg. To convert to seawater these values need to be
        multiplied by sw

        &#34;&#34;&#34;

        S = self.salinity
        swc = (1000 + S) / 1000
        self.dic = 0.00204 * swc
        self.boron = 0.00042 * swc
        self.oh = 0.00001 * swc

    def __init_carbon__(self) -&gt; None:
        &#34;&#34;&#34;Calculate the carbon equilibrium values as function of
        temperature T and salinity S

        &#34;&#34;&#34;

        from math import exp, log, log10

        T = 273.15 + self.temperature
        S = self.salinity

        # After Weiss 1974
        lnK0: float = (
            93.4517 * 100 / T
            - 60.2409
            + 23.3585 * log(T / 100)
            + S * (0.023517 - 0.023656 * T / 100 + 0.0047036 * (T / 100) ** 2)
        )

        lnk1: float = (
            -2307.1266 / T
            + 2.83655
            - 1.5529413 * log(T)
            + S ** 0.5 * (-4.0484 / T - 0.20760841)
            + S * 0.08468345
            + S ** (3 / 2) * -0.00654208
            + log(1 - 0.001006 * S)
        )

        lnk2: float = (
            -9.226508
            - 3351.6106 / T
            - 0.2005743 * log(T)
            + (-0.106901773 - 23.9722 / T) * S ** 0.5
            + 0.1130822 * S
            - 0.00846934 * S ** 1.5
            + log(1 - 0.001006 * S)
        )

        self.K0: float = exp(lnK0)
        self.K1: float = exp(lnk1)
        self.K2: float = exp(lnk2)

        self.K1 = self.__pressure_correction__(&#34;K1&#34;, self.K1)
        self.K2 = self.__pressure_correction__(&#34;K2&#34;, self.K2)

        self.co2 = self.dic / (
            1 + self.K1 / self.hplus + self.K1 * self.K2 / self.hplus ** 2
        )
        self.hco3 = self.dic / (1 + self.hplus / self.K1 + self.K2 / self.hplus)
        self.co3 = self.dic / (
            1 + self.hplus / self.K2 + self.hplus ** 2 / (self.K1 * self.K2)
        )

    def __init_boron__(self) -&gt; None:
        &#34;&#34;&#34;Calculate the boron equilibrium values as function of
        temperature T and salinity S

        &#34;&#34;&#34;

        from math import exp, log

        T = 273.15 + self.temperature
        S = self.salinity

        lnkb = (
            (
                -8966.9
                - 2890.53 * S ** 0.5
                - 77.942 * S
                + 1.728 * S ** 1.5
                - 0.0996 * S ** 2
            )
            / T
            + 148.0248
            + 137.1942 * S ** 0.5
            + 1.62142 * S
            - (24.4344 + 25.085 * S ** 0.5 + 0.2474 * S) * log(T)
            + 0.053105 * S ** 0.5 * T
        )

        self.KB = exp(lnkb)
        self.KB = self.__pressure_correction__(&#34;KB&#34;, self.KB)

        self.boh4 = self.boron * self.KB / (self.hplus + self.KB)
        self.boh3 = self.boron - self.boh4

    def __init_water__(self) -&gt; None:
        &#34;&#34;&#34;Calculate the water equilibrium values as function of
        temperature T and salinity S

        &#34;&#34;&#34;

        from math import exp, log

        T = 273.15 + self.temperature
        S = self.salinity

        lnKW = (
            148.96502
            - 13847.27 / T
            - 23.6521 * log(T)
            + (118.67 / T - 5.977 + 1.0495 * log(T)) * S ** 0.5
            - 0.01615 * S
        )
        self.KW = exp(lnKW)
        self.KW = self.__pressure_correction__(&#34;KW&#34;, self.KW)
        self.oh = self.KW / self.hplus

    def __pressure_correction__(self, n: str, K: float) -&gt; float:
        &#34;&#34;&#34;Correct K-values for pressure. After Zeebe and Wolf Gladrow 2001

        name = name of K-value, i.e. &#34;K1&#34;
        K = uncorrected value
        T = temperature in Deg C
        P = pressure in atm
        &#34;&#34;&#34;

        from math import exp, log

        R: float = 83.131
        Tc: float = self.temperature
        T: float = 273.15 + Tc
        P: float = self.pressure
        RT: float = R * T

        A: dict = {}
        A[&#34;K1&#34;]: list = [25.50, 0.1271, 0.0, 3.08, 0.0877]
        A[&#34;K2&#34;]: list = [15.82, -0.0219, 0.0, -1.13, -0.1475]
        A[&#34;KB&#34;]: list = [29.48, 0.1622, 2.6080, 2.84, 0.0]
        A[&#34;KW&#34;]: list = [25.60, 0.2324, -3.6246, 5.13, 0.0794]
        A[&#34;KS&#34;]: list = [18.03, 0.0466, 0.3160, 4.53, 0.0900]
        A[&#34;KF&#34;]: list = [9.780, -0.0090, -0.942, 3.91, 0.054]
        A[&#34;Kca&#34;]: list = [48.76, 0.5304, 0.0, 11.76, 0.3692]
        A[&#34;Kar&#34;]: list = [46.00, 0.5304, 0.0, 11.76, 0.3692]

        a: list = A[n]

        DV: float = -a[0] + (a[1] * Tc) + (a[2] / 1000 * Tc ** 2)
        DK: float = -a[3] / 1000 + (a[4] / 1000 * Tc) + (0 * Tc ** 2)

        # print(f&#34;DV = {DV}&#34;)
        # print(f&#34;DK = {DK}&#34;)
        # print(f&#34;log k= {log(K)}&#34;)

        lnkp: float = -(DV / RT) * P + (0.5 * DK / RT) * P ** 2 + log(K)
        # print(lnkp)

        return exp(lnkp)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="esbmtk.esbmtk.esbmtkBase" href="esbmtk.html#esbmtk.esbmtk.esbmtkBase">esbmtkBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="esbmtk.carbonate_chemisrty.SeawaterConstants.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Printout pK values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self) -&gt; None:
    &#34;&#34;&#34;Printout pK values. &#34;&#34;&#34;

    from math import log10

    for n in self.species:
        v = getattr(self, n)
        print(f&#34;{n} = {v * 1E6:.2f} nmol/l&#34;)

    print(f&#34;pH = {-log10(self.hplus):.2f}\n&#34;)
    print(f&#34;salinity = {self.salinity:.2f}&#34;)
    print(f&#34;temperature = {self.temperature:.2f}\n&#34;)

    for n in self.constants:
        K = getattr(self, n)
        pk = getattr(self, f&#34;p{n.lower()}&#34;)
        print(f&#34;{n} = {K:.2e}, p{n} = {pk:.2f}&#34;)</code></pre>
</details>
</dd>
<dt id="esbmtk.carbonate_chemisrty.SeawaterConstants.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs: dict) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update values if necessary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs: dict) -&gt; None:
    &#34;&#34;&#34;Update values if necessary&#34;&#34;&#34;

    from math import log10

    if kwargs:
        self.lrk: list = []
        self.__validateandregister__(kwargs)

    # update K values and species concentrations according to P, S, and T
    self.__init_std_seawater__()
    self.__init_carbon__()
    self.__init_boron__()
    self.__init_water__()

    # get total alkalinity

    self.ca = self.hco3 + 2 * self.co3
    self.ta = self.ca + self.boh4 + self.oh - self.hplus

    # update pk values
    for n in self.constants:
        v = getattr(self, n)
        pk = f&#34;p{n.lower()}&#34;
        setattr(self, pk, -log10(v))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="esbmtk.esbmtk.esbmtkBase" href="esbmtk.html#esbmtk.esbmtk.esbmtkBase">esbmtkBase</a></b></code>:
<ul class="hlist">
<li><code><a title="esbmtk.esbmtk.esbmtkBase.info" href="esbmtk.html#esbmtk.esbmtk.esbmtkBase.info">info</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="esbmtk" href="index.html">esbmtk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="esbmtk.carbonate_chemisrty.calc_CA" href="#esbmtk.carbonate_chemisrty.calc_CA">calc_CA</a></code></li>
<li><code><a title="esbmtk.carbonate_chemisrty.calc_H" href="#esbmtk.carbonate_chemisrty.calc_H">calc_H</a></code></li>
<li><code><a title="esbmtk.carbonate_chemisrty.calc_pCO2" href="#esbmtk.carbonate_chemisrty.calc_pCO2">calc_pCO2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="esbmtk.carbonate_chemisrty.SeawaterConstants" href="#esbmtk.carbonate_chemisrty.SeawaterConstants">SeawaterConstants</a></code></h4>
<ul class="">
<li><code><a title="esbmtk.carbonate_chemisrty.SeawaterConstants.show" href="#esbmtk.carbonate_chemisrty.SeawaterConstants.show">show</a></code></li>
<li><code><a title="esbmtk.carbonate_chemisrty.SeawaterConstants.update" href="#esbmtk.carbonate_chemisrty.SeawaterConstants.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>